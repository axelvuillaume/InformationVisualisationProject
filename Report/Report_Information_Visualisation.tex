\documentclass{article}

\usepackage[ddmmyyyy]{datetime} 
\usepackage{caption}
\usepackage[backend=bibtex8]{biblatex}
\usepackage{hyperref}
\usepackage{amsmath}

\begin{document}
	\title{Report Information Visualisation}
	\author{Oru√ß Kaplan; Ward Van den Bossche; Axel Daniel Vuillaume \& Laurens Devloo}
	\maketitle
	\tableofcontents
	\newpage
	
	\section{Data}
	
	\subsection{Dataset}
	
	This project will use two different datasets
	
	\begin{itemize}
		\item \href{https://www.kaggle.com/datasets/fronkongames/steam-games-dataset/code}{Steam Game Data}
		\item Steam API for user information
	\end{itemize}
	
	The steam game dataset contains data about games received from the Steam API and Steam Spy. The contained columns are name of the game, the release date, the amount of DLC for the game, a short description of the game, is the game is on Linux, Windows or on Mac, a metacritic score, the amount of achievements the game has, user score the amount of negative reviews and positive reviews, an email address for help, an average playtime and the amount of owners of the game. This data is found in a JSON-file.\\
	\\
	The second dataset is user information gotten by the Steam API. This dataset will contain the data about a given Steam user. This information includes the games he plays and the user-profiles of his friends.
	
	\subsection{Target User}
	
	The target users are games, both the casual one as the more experienced one. The site will be able to recommend gamers games that might be interesting for them. It does this in two ways the first one is by showing the user general information about the games available. The second way is by giving insights in the current most popular games/genres or categories of the users and showing other games in the same vein. The user will also be able to see what is friends are playing to reap some inspirations in this way.
	
	\newpage
	
	\section{Preprocessing}
	
	\subsection{Data Cleaning}
	
	This dataset as it stands needs more work in order to be usable in visualisations. This preprocessing will exists out of deleting not used columns, cleaning cells that point to outliers and divide the certain columns in separate.\\
	\\
	The first thing that will happen is to delete unused column such as \texttt{packages}, \texttt{screenshots}, \texttt{movies}, \texttt{score\_rank}, \texttt{header\_image}, \texttt{reviews}, \texttt{website}, \texttt{support\_url}, \texttt{notes}, \texttt{support\_email}, \texttt{median\_playtime\_2weeks}, \texttt{required\_age}, \texttt{metacritic\_url}, \texttt{detailed\_description}, \texttt{about\_the\_game} and \texttt{average\_playtime\_2week}.\\
	These columns where deleted because they where either unvisualizable as they where things like urls, notes, descriptions or emails or the columns contained data that was not usable in our specific use case as is the case with \texttt{average\_playtime\_2weeks}.\\
	\\
	After this we delete outliers or values that seem to show useless rows. First way we do this is by deleting all games with no sales. To do this we look where the \texttt{estimated\_owners} column equals \texttt{0-0} and delete these.\\
	Besides this we see also that some games have no reviews or no categories. These are understood to be developer tests and so can be deleted.\\
	If we look at the distribution of the prices we can see that we have most of them are under the 200\$. We have 1 game of 999\$ in order to not to affect the rest of the dataset this outlier is also removed from the dataset.\\
	\\
	The column \texttt{estimated\_owners} is a range between the minimal amount of owners and the maximum. In order for easier work with this data this is split into 2 different columns: the \texttt{min\_owners} and the \texttt{max\_owners}.\\
	\\
	To end we look at the \texttt{median\_playtime\_forever} column. If these values are above 60,000 this would mean that the playerbase would have played more then 1,000 hours. This would not be very realistic and so these values will be set to 0 in order to prevent skewing the data. Rows with this amount of hours will mostly not be games, but more overlays or pieces of software that is running in the background.\\
	\\
	The dataset still contains columns such as \texttt{categories} or \texttt{tags} that consist out of a list of values. In order to improve our performances we shall convert these fields separate table linked to the main table using \texttt{app\_id} as foreign key.\\
	In this implementation we went with the approach that only the games with a not-empty lists will be included in the new table. Each new item of the list will be a new row in the table, making the primary key the combination of \texttt{app\_id} and value of the list.\\
	\\
	We can see in the data that there are quite a lot of different type of score columns. In order to work easier with the data we make a custom score column named\texttt{score}.\\
	For this custom score we take into account the columns: \texttt{price}, \texttt{metacritic\_score}, \texttt{positive}, \texttt{negative} and \texttt{median\_playtime\_forever}.\\
	The first thing that has to happen is a normalisation of the columns so they are all in the same range. For the price we would like a range between $\left[0;1\right]$.
	
	$$normalised\_price = \frac{1}{\sqrt{\max{\left(price, 1\right)}}}$$
	
	We see that we favour lower prices. The max function will prevent divisions by 0.\\
	The following 2 normalised score are the \texttt{metacritic\_score} and \texttt{positive\_ratio}. Following the next formulas:
	
	\begin{align}
		metacritic\_score\_normalized &= \frac{metacritic\_score}{\max{\left(metacritic\_score\right)}} \\
		positive\_ratio &= \frac{positive}{\max{\left(positive + negative, 1\right)}}
	\end{align}
	
	The total review is a good indicator of how many people bought the game, so this term effectively serves as a "amount of sales"  score. The purpose of this is more to filter out games with very few reviews. This means games where the data is skewed to be overly positive or negative.
	
	$$total\_reviews\_normalized = \frac{positive + negative}{\max{\left(positive + negative\right)}}$$
	$$median\_playtime\_forever\_normalized = \frac{median\_playtime\_forever}{\max{\left(median\_playtime\_forever\right)}}$$
	
	After normalizing all the data we can give a weight to each column. 
	
	\newpage
	
	\section{Visualisation}
	\subsection{Home}

	\subsection{Profile}

	\subsection{Recommender}
	\subsubsection{User Vs Friends Panel}
	The aim of this visualisation is to compare our tastes with those of our friends. To do this, it consists of two Spider Graphs, one for yourself and one for the selected friend, as well as two graphs (one for each) that appear in the centre, listing the top 5 games for the category/genre selected in the spider graph. The code for this visualisation can be found in \textit{user\_vs\_friends\_panel.py} the file \textit{hexagon.py} and \textit{top\_games\_forUVFpanel.py}.

	\paragraph{Spider Graphs}
	\begin{itemize}
		\item Goal : Show the user's preferences in terms of categories/genres by comparing the total playtime of the games in each category/genre and the total number of games played in each category/genre.
		\item Data : Get the games genre and categories from the dataset and the user's playtime and number of games played from the Steam API.
		\item Features/Interaction : You can choose between the categories and genres of the games. You can change the number of categories/genres displayed by choosing the number of sides of the spider graph (it will show first the most played categories/genres). Hovering to get the number of games played and the total playtime in hours for each label (with a legend). Clicking on a label will show the top 5 games in this category/genre in the center graph. You can select a friend to compare your preferences of your top genre/categories to his preferences for the same genre/categories you like.
		\item Menu : Disposition on the top left, except for the friend selector which is above his spider graph (which makes more sense).
		\item Design and choice : The user and the friend are in disctinct colors, blueish for the user and redish for the friend to make clear distinction. The user and friend infos are in distinct spidergraph because the goal is to see the tastes by looking to the ratio between the playtime and the owned games per genre/category in each spidergraph. This also avoid having too much information in one graph and better for colorblindness and black/white since tranparency is envolved in the colors.
		\item Implementation : Since the radar charts are a bit limited in Ploty, we decided to do a custom implemented spider graph made with a scatter plot and lines between the points (a little bit risky).
		\item Code file : \textit{hexagon.py}
	\end{itemize}

	\paragraph{Center Graphs}
	\begin{itemize}
		\item Goal : Show the top 5 games in the selected category/genre for the user and the friend in order to see what games are the most played by our friend in the same category/genre in order to get some inspiration.
		\item Data : Get the games from the dataset and the user's playtime from the Steam API.
		\item Features/Interaction : Hovering to get the playtime in hours for each game.
		\item Menu : The spider graphs labels (whatever the user or the friend) will act as a menu to select the category/genre to display the top 5 games.
		\item Design and choice : The user and the friend are in disctinct colors, blueish for the user and redish for the friend to make clear distinction again. \texttt{The scales for the playtime} are not the same for two reasons: first because of the goal of the graph and second because a huge difference in playtime between the user and the friend would make the user's playtime unreadable (maybe a synchronized selection between the two graphs could be pertinent here (as saw in the Exercices Sessions with the lasso) but didn't have the time to implement it).
		\item Implementation : A simple bar chart with the top 5 games for the selected category/genre.
		\item Code file : \textit{top\_games\_forUVFpanel.py}
	\end{itemize}
	
	\section{Evaluation}
	
	
	\newpage
\end{document}